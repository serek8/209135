\documentclass[11pt]{article}
\usepackage[top=1in, bottom=0.5in, left=1in, right=1in]{geometry}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\selectlanguage{polish}
\usepackage{graphicx}
\begin{document}
\title{Laboratorium 3}
\author{Jan Seredyński}
\date{\today}
\maketitle

\section{Wstęp}
Zadaniem laboratorium jest pomiar czasu wykonania operacji wypelnienia stosu. Do wykonania analizy zstosowałem trzy implementacje:dwie tablicowe i jedna oparta na liście.


\section{Schematy odpowiednich struktur}

Lista dwukierunkowa
\includegraphics[width=5in]{lista2_1.png} 
\par\vspace{\baselineskip}
\hrule
\par\vspace{\baselineskip}
Stos, kolejka
\includegraphics[width=3in]{stackqueue.png} 
\newpage

\section{Wydajność stosu na tablicy - strategia inkrementacyjna}
Podczas tej próby stos jest opraty na tablicy dynamicznej, która przy każdym pushowaniu twory nową tablice większą o 1, a następnie kopiuje pozostałe elementy do nowoutworznej tablicy, a na końcu wpisuje nowy element.\\\
Całkowity czas T(n) wykonania n operacji push jest proporcjonalny do: \\\
\begin{center}
n + c + 2c + 3c + 4c + ... + kc =\\\
n + c(1 + 2 + 3 + ... + k)=\\\
n + ck(k+1)/2\\\

\begin{large} T(n) jest w $O(n+k^2)$, tj. $O(n^2)$ \end{large}\\\
\end{center}
gdzie c jest stałą,\\\
k-wielokrotność zastąpień,\\\

\includegraphics[width=6.5in]{3stos_dyn_o_1.png}
Na podstawie wykresu można stwierdzić, że ta implementacja ma przyrost geometryczny - kwadratowy, czyli złożoność obliczniowa wynosi $O(n^2)$.
\section{Wydajność stosu na tablicy - strategia podwajania}
Podczas tej próby stos jest opraty na tablicy dynamicznej, która przy każdym pushowaniu sprawdza czy tablica pomieśći nowy element, a gdy jest potrzeba zaalokowania nowej pamięci tworzy nową tablice większą o 100\%, a następnie kopiuje pozostałe elementy do nowoutworznej tablicy, a na końcu pushuje nowy element.\\\


Tablica zostanie zastąpiona k = $log_2n$ razy
Całkowity czas T(n) jest proporcjonalny do:
\begin{center}
$n+1+2+4+8+...+2^k = $\\\
$n+2^(k+1) -1 = 2n-1$\\\
\end{center}
gdzie T(n) jest w O(n)


Na tym samym wykresie została również złożoność obliczeniowa O(n) implementacji listy.\\\
\includegraphics[width=6.5in]{3stos_dyn_o_200ilista.png}
Na podstawie wykresu można stwierdzić, że obie te implementacje mają przyrost liniowy, co spełdnia założenie, że charakteryzują się złożonością obliczniową O(n).
\section{Podsumowanie}
Najbardziej wydajnyą implementacją jest zoptymalizowanystos na tablicy(200\%). Optymalizacje tutaj otrzymujemy poprzez strategie podwajania, która osiąga złożoność obliczeniową O(n), co jest dużą różnicą w porównaniu do strategi inkrementacyjnej której wyniki złożoności obliczeniowej sięgają aż $O(n^2)$. 

Implementacja oprta na liście wydajnym algorytmem, ponieważ jej złożoność obliczeniowa wynosi O(n), którą osiągamy dzięki temu, że nie ma potrzeby kopiowania starych elementów przy tworzeniu nowej większej tablicy, jak w przypadku wcześniejszej implementacji.
\end{document}